package com.anthemengineering.sox.jna;

import com.sun.jna.Callback;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.ByteBuffer;
import java.nio.IntBuffer;
/**
 * JNA Wrapper for library <b>sox</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
@SuppressWarnings({"unused", "JavaDoc"})
public interface SoxLibrary extends Library {
	String JNA_LIBRARY_NAME = "sox";
	SoxLibrary INSTANCE = Native.load(SoxLibrary.JNA_LIBRARY_NAME, SoxLibrary.class);

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_bool {
		/**
		 * Ensure a signed type<br>
		 * <i>native declaration : sox.h:519</i>
		 */
		int sox_bool_dummy = -1;
		/**
		 * < False = 0.<br>
		 * <i>native declaration : sox.h:520</i>
		 */
		int sox_false = 0;
		/**
		 * < True = 1.<br>
		 * <i>native declaration : sox.h:521</i>
		 */
		int sox_true = 1;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_option_t {
		/**
		 * < Option specified as no = 0.<br>
		 * <i>native declaration : sox.h:529</i>
		 */
		int sox_option_no = 0;
		/**
		 * < Option specified as yes = 1.<br>
		 * <i>native declaration : sox.h:530</i>
		 */
		int sox_option_yes = 1;
		/**
		 * < Option unspecified = 2.<br>
		 * <i>native declaration : sox.h:531</i>
		 */
		int sox_option_default = 2;
	}

	/**
	 * Client API:<br>
	 * The libSoX-specific error codes.<br>
	 * libSoX functions may return these codes or others that map from errno codes.<br>
	 * <i>native declaration : sox.h:539</i><br>
	 * enum values
	 */
	interface sox_error_t {
		/**
		 * < Function succeeded = 0<br>
		 * <i>native declaration : sox.h:540</i>
		 */
		int SOX_SUCCESS = 0;
		/**
		 * < End Of File or other error = -1<br>
		 * <i>native declaration : sox.h:541</i>
		 */
		int SOX_EOF = -1;
		/**
		 * < Invalid Audio Header = 2000<br>
		 * <i>native declaration : sox.h:542</i>
		 */
		int SOX_EHDR = 2000;
		/**
		 * < Unsupported data format = 2001<br>
		 * <i>native declaration : sox.h:543</i>
		 */
		int SOX_EFMT = 2001;
		/**
		 * < Can't alloc memory = 2002<br>
		 * <i>native declaration : sox.h:544</i>
		 */
		int SOX_ENOMEM = 2002;
		/**
		 * < Operation not permitted = 2003<br>
		 * <i>native declaration : sox.h:545</i>
		 */
		int SOX_EPERM = 2003;
		/**
		 * < Operation not supported = 2004<br>
		 * <i>native declaration : sox.h:546</i>
		 */
		int SOX_ENOTSUP = 2004;
		/**
		 * < Invalid argument = 2005<br>
		 * <i>native declaration : sox.h:547</i>
		 */
		int SOX_EINVAL = 2005;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_version_flags_t {
		/**
		 * < No special features = 0.<br>
		 * <i>native declaration : sox.h:555</i>
		 */
		int sox_version_none = 0;
		/**
		 * < popen = 1.<br>
		 * <i>native declaration : sox.h:556</i>
		 */
		int sox_version_have_popen = 1;
		/**
		 * < magic = 2.<br>
		 * <i>native declaration : sox.h:557</i>
		 */
		int sox_version_have_magic = 2;
		/**
		 * < threads = 4.<br>
		 * <i>native declaration : sox.h:558</i>
		 */
		int sox_version_have_threads = 4;
		/**
		 * < memopen = 8.<br>
		 * <i>native declaration : sox.h:559</i>
		 */
		int sox_version_have_memopen = 8;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_encoding_t {
		/**
		 * < encoding has not yet been determined<br>
		 * <i>native declaration : sox.h:567</i>
		 */
		int SOX_ENCODING_UNKNOWN = 0;
		/**
		 * < signed linear 2's comp: Mac<br>
		 * <i>native declaration : sox.h:569</i>
		 */
		int SOX_ENCODING_SIGN2 = 1;
		/**
		 * < unsigned linear: Sound Blaster<br>
		 * <i>native declaration : sox.h:570</i>
		 */
		int SOX_ENCODING_UNSIGNED = 2;
		/**
		 * < floating point (binary format)<br>
		 * <i>native declaration : sox.h:571</i>
		 */
		int SOX_ENCODING_FLOAT = 3;
		/**
		 * < floating point (text format)<br>
		 * <i>native declaration : sox.h:572</i>
		 */
		int SOX_ENCODING_FLOAT_TEXT = 4;
		/**
		 * < FLAC compression<br>
		 * <i>native declaration : sox.h:573</i>
		 */
		int SOX_ENCODING_FLAC = 5;
		/**
		 * < Mac FSSD files with Huffman compression<br>
		 * <i>native declaration : sox.h:574</i>
		 */
		int SOX_ENCODING_HCOM = 6;
		/**
		 * < WavPack with integer samples<br>
		 * <i>native declaration : sox.h:575</i>
		 */
		int SOX_ENCODING_WAVPACK = 7;
		/**
		 * < WavPack with float samples<br>
		 * <i>native declaration : sox.h:576</i>
		 */
		int SOX_ENCODING_WAVPACKF = 8;
		/**
		 * < u-law signed logs: US telephony, SPARC<br>
		 * <i>native declaration : sox.h:577</i>
		 */
		int SOX_ENCODING_ULAW = 9;
		/**
		 * < A-law signed logs: non-US telephony, Psion<br>
		 * <i>native declaration : sox.h:578</i>
		 */
		int SOX_ENCODING_ALAW = 10;
		/**
		 * < G.721 4-bit ADPCM<br>
		 * <i>native declaration : sox.h:579</i>
		 */
		int SOX_ENCODING_G721 = 11;
		/**
		 * < G.723 3 or 5 bit ADPCM<br>
		 * <i>native declaration : sox.h:580</i>
		 */
		int SOX_ENCODING_G723 = 12;
		/**
		 * < Creative Labs 8 --> 2,3,4 bit Compressed PCM<br>
		 * <i>native declaration : sox.h:581</i>
		 */
		int SOX_ENCODING_CL_ADPCM = 13;
		/**
		 * < Creative Labs 16 --> 4 bit Compressed PCM<br>
		 * <i>native declaration : sox.h:582</i>
		 */
		int SOX_ENCODING_CL_ADPCM16 = 14;
		/**
		 * < Microsoft Compressed PCM<br>
		 * <i>native declaration : sox.h:583</i>
		 */
		int SOX_ENCODING_MS_ADPCM = 15;
		/**
		 * < IMA Compressed PCM<br>
		 * <i>native declaration : sox.h:584</i>
		 */
		int SOX_ENCODING_IMA_ADPCM = 16;
		/**
		 * < Dialogic/OKI Compressed PCM<br>
		 * <i>native declaration : sox.h:585</i>
		 */
		int SOX_ENCODING_OKI_ADPCM = 17;
		/**
		 * < Differential PCM: Fasttracker 2 (xi)<br>
		 * <i>native declaration : sox.h:586</i>
		 */
		int SOX_ENCODING_DPCM = 18;
		/**
		 * < Delta Width Variable Word<br>
		 * <i>native declaration : sox.h:587</i>
		 */
		int SOX_ENCODING_DWVW = 19;
		/**
		 * < Delta Width Variable Word N-bit<br>
		 * <i>native declaration : sox.h:588</i>
		 */
		int SOX_ENCODING_DWVWN = 20;
		/**
		 * < GSM 6.10 33byte frame lossy compression<br>
		 * <i>native declaration : sox.h:589</i>
		 */
		int SOX_ENCODING_GSM = 21;
		/**
		 * < MP3 compression<br>
		 * <i>native declaration : sox.h:590</i>
		 */
		int SOX_ENCODING_MP3 = 22;
		/**
		 * < Vorbis compression<br>
		 * <i>native declaration : sox.h:591</i>
		 */
		int SOX_ENCODING_VORBIS = 23;
		/**
		 * < AMR-WB compression<br>
		 * <i>native declaration : sox.h:592</i>
		 */
		int SOX_ENCODING_AMR_WB = 24;
		/**
		 * < AMR-NB compression<br>
		 * <i>native declaration : sox.h:593</i>
		 */
		int SOX_ENCODING_AMR_NB = 25;
		/**
		 * < Continuously Variable Slope Delta modulation<br>
		 * <i>native declaration : sox.h:594</i>
		 */
		int SOX_ENCODING_CVSD = 26;
		/**
		 * < Linear Predictive Coding<br>
		 * <i>native declaration : sox.h:595</i>
		 */
		int SOX_ENCODING_LPC10 = 27;
		/**
		 * < Opus compression<br>
		 * <i>native declaration : sox.h:596</i>
		 */
		int SOX_ENCODING_OPUS = 28;
		/**
		 * < End of list marker<br>
		 * <i>native declaration : sox.h:598</i>
		 */
		int SOX_ENCODINGS = 29;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_encodings_flags_t {
		/**
		 * < no flags specified (implies lossless encoding) = 0.<br>
		 * <i>native declaration : sox.h:606</i>
		 */
		int sox_encodings_none = 0;
		/**
		 * < encode, decode: lossy once = 1.<br>
		 * <i>native declaration : sox.h:607</i>
		 */
		int sox_encodings_lossy1 = 1;
		/**
		 * < encode, decode, encode, decode: lossy twice = 2.<br>
		 * <i>native declaration : sox.h:608</i>
		 */
		int sox_encodings_lossy2 = 2;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface sox_plot_t {
		/**
		 * < No plot = 0.<br>
		 * <i>native declaration : sox.h:616</i>
		 */
		int sox_plot_off = 0;
		/**
		 * < Octave plot = 1.<br>
		 * <i>native declaration : sox.h:617</i>
		 */
		int sox_plot_octave = 1;
		/**
		 * < Gnuplot plot = 2.<br>
		 * <i>native declaration : sox.h:618</i>
		 */
		int sox_plot_gnuplot = 2;
		/**
		 * < Plot data = 3.<br>
		 * <i>native declaration : sox.h:619</i>
		 */
		int sox_plot_data = 3;
	}

	/**
	 * Client API:<br>
	 * Loop modes: upper 4 bits mask the loop blass, lower 4 bits describe<br>
	 * the loop behaviour, for example single shot, bidirectional etc.<br>
	 * <i>native declaration : sox.h:627</i><br>
	 * enum values
	 */
	interface sox_loop_flags_t {
		/**
		 * < single-shot = 0<br>
		 * <i>native declaration : sox.h:628</i>
		 */
		int sox_loop_none = 0;
		/**
		 * < forward loop = 1<br>
		 * <i>native declaration : sox.h:629</i>
		 */
		int sox_loop_forward = 1;
		/**
		 * < forward/back loop = 2<br>
		 * <i>native declaration : sox.h:630</i>
		 */
		int sox_loop_forward_back = 2;
		/**
		 * < 8 loops (] = 32<br>
		 * <i>native declaration : sox.h:631</i>
		 */
		int sox_loop_8 = 32;
		/**
		 * < AIFF style, one sustain & one decay loop = 64<br>
		 * <i>native declaration : sox.h:632</i>
		 */
		int sox_loop_sustain_decay = 64;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface lsx_io_type {
		/**
		 * < File is a real file = 0.<br>
		 * <i>native declaration : sox.h:641</i>
		 */
		int lsx_io_file = 0;
		/**
		 * < File is a pipe (no seeking) = 1.<br>
		 * <i>native declaration : sox.h:642</i>
		 */
		int lsx_io_pipe = 1;
		/**
		 * < File is a URL (no seeking) = 2.<br>
		 * <i>native declaration : sox.h:643</i>
		 */
		int lsx_io_url = 2;
	}

	/** < Default parameters (case-insensitive). */
	int lsx_find_enum_item_none = 0;
	/** < Enable case-sensitive search. */
	int lsx_find_enum_item_case_sensitive = 1;
	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface lsx_option_arg_t {
		/**
		 * < Option does not have an argument.<br>
		 * <i>native declaration : sox.h:2535</i>
		 */
		int lsx_option_arg_none = 0;
		/**
		 * < Option requires an argument.<br>
		 * <i>native declaration : sox.h:2536</i>
		 */
		int lsx_option_arg_required = 1;
		/**
		 * < Option can optionally be followed by an argument.<br>
		 * <i>native declaration : sox.h:2537</i>
		 */
		int lsx_option_arg_optional = 2;
	}

	/**
	 * <i>native declaration : sox.h</i><br>
	 * enum values
	 */
	interface lsx_getopt_flags_t {
		/**
		 * < no flags (no output, not long-only)<br>
		 * <i>native declaration : sox.h:2545</i>
		 */
		int lsx_getopt_flag_none = 0;
		/**
		 * < if set, invalid options trigger lsx_warn output<br>
		 * <i>native declaration : sox.h:2546</i>
		 */
		int lsx_getopt_flag_opterr = 1;
		/**
		 * < if set, recognize -option as a long option<br>
		 * <i>native declaration : sox.h:2547</i>
		 */
		int lsx_getopt_flag_longonly = 2;
	}

	/** <i>native declaration : sox.h</i> */
	int SOX_LIB_VERSION_CODE = ((14) << 16) + ((4) << 8) + (2);
	/** <i>native declaration : sox.h</i> */
	int SOX_INT8_MAX = -1 >> (33 - (8));
	/** <i>native declaration : sox.h</i> */
	int SOX_INT16_MAX = -1 >> (33 - (16));
	/** <i>native declaration : sox.h</i> */
	int SOX_INT24_MAX = -1 >> (33 - (24));
	/** <i>native declaration : sox.h</i> */
	int SOX_INT32_MAX = -1 >> (33 - (32));
	/** <i>native declaration : sox.h</i> */
	int SOX_SAMPLE_PRECISION = 32;
	/** <i>native declaration : sox.h</i> */
	int SOX_SAMPLE_NEG = 1 << ((32) - 1);
	/** <i>native declaration : sox.h</i> */
	size_t SOX_SIZE_MAX = new size_t(-1);
	/** <i>native declaration : sox.h</i> */
	int SOX_UNSPEC = 0;
	/** <i>native declaration : sox.h</i> */
	int SOX_DEFAULT_CHANNELS = 2;
	/** <i>native declaration : sox.h</i> */
	int SOX_DEFAULT_RATE = 48000;
	/** <i>native declaration : sox.h</i> */
	int SOX_DEFAULT_PRECISION = 16;
	/** <i>native declaration : sox.h</i> */
	int SOX_MAX_NLOOPS = 8;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_NOSTDIO = 0x0001;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_DEVICE = 0x0002;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_PHONY = 0x0004;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_REWIND = 0x0008;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_BIT_REV = 0x0010;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_NIB_REV = 0x0020;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_ENDIAN = 0x0040;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_ENDBIG = 0x0080;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_MONO = 0x0100;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_STEREO = 0x0200;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_QUAD = 0x0400;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_CHANS = 0x0100 | 0x0200 | 0x0400;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_LIT_END = 0x0040;
	/** <i>native declaration : sox.h</i> */
	int SOX_FILE_BIG_END = 0x0040 | 0x0080;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_CHAN = 1;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_RATE = 2;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_PREC = 4;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_LENGTH = 8;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_MCHAN = 16;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_NULL = 32;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_DEPRECATED = 64;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_GAIN = 128;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_MODIFY = 256;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_ALPHA = 512;
	/** <i>native declaration : sox.h</i> */
	int SOX_EFF_INTERNAL = 1024;
	/** <i>native declaration : sox.h</i> */
	int SOX_SEEK_SET = 0;
	/** <i>native declaration : sox.h</i> */
	interface sox_output_message_handler_t extends Callback {
		/**
		 * @param level < 1 = FAIL, 2 = WARN, 3 = INFO, 4 = DEBUG, 5 = DEBUG_MORE, 6 = DEBUG_MOST.<br>
		 * @param filename < Source code __FILENAME__ from which message originates.<br>
		 * @param fmt < Message format string.<br>
		 * @param ap < Message format parameters.
		 */
		void apply(int level, Pointer filename, Pointer fmt, Object... ap);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_fn_t extends Callback {
		sox_format_handler_t apply();
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_effect_fn_t extends Callback {
		sox_effect_handler_t apply();
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_startread extends Callback {
		/** @param ft < Format pointer. */
		int apply(sox_format_t ft);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_read extends Callback {
		/**
		 * @param ft < Format pointer.<br>
		 * @param buf < Buffer from which to read samples.<br>
		 * @param len < Number of samples available in buf.
		 */
		size_t apply(sox_format_t ft, IntByReference buf, size_t len);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_stopread extends Callback {
		/** @param ft < Format pointer. */
		int apply(sox_format_t ft);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_startwrite extends Callback {
		/** @param ft < Format pointer. */
		int apply(sox_format_t ft);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_write extends Callback {
		/**
		 * @param ft < Format pointer.<br>
		 * @param buf < Buffer to which samples are written.<br>
		 * @param len < Capacity of buf, measured in samples.
		 */
		size_t apply(sox_format_t ft, IntByReference buf, size_t len);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_stopwrite extends Callback {
		/** @param ft < Format pointer. */
		int apply(sox_format_t ft);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_format_handler_seek extends Callback {
		/**
		 * @param ft < Format pointer.<br>
		 * @param offset < Sample offset to which reader should be positioned.
		 */
		int apply(sox_format_t ft, long offset);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_effect_handler_getopts extends Callback {
		/**
		 * @param effp < Effect pointer.<br>
		 * @param argc < Number of arguments in argv.<br>
		 * @param argv < Array of command-line arguments.
		 */
		int apply(sox_effect_t effp, int argc, PointerByReference argv);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_effect_handler extends Callback {
		/** @param effp < Effect pointer. */
		int apply(sox_effect_t effp);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_effect_handler_flow extends Callback {
		/**
		 * @param effp < Effect pointer.<br>
		 * @param ibuf < Buffer from which to read samples.<br>
		 * @param obuf < Buffer to which samples are written.<br>
		 * @param isamp < On entry, contains capacity of ibuf; on exit, contains number of samples consumed.<br>
		 * @param osamp < On entry, contains capacity of obuf; on exit, contains number of samples written.
		 */
		int apply(sox_effect_t effp, IntByReference ibuf, IntByReference obuf, size_t.ByReference isamp, size_t.ByReference osamp);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_effect_handler_drain extends Callback {
		/**
		 * @param effp < Effect pointer.<br>
		 * @param obuf < Buffer to which samples are written.<br>
		 * @param osamp < On entry, contains capacity of obuf; on exit, contains number of samples written.
		 */
		int apply(sox_effect_t effp, IntByReference obuf, size_t.ByReference osamp);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_flow_effects_callback extends Callback {
		int apply(int all_done, Pointer client_data);
	}

	/** <i>native declaration : sox.h</i> */
	interface sox_playlist_callback_t extends Callback {
		int apply(Pointer callback_data, Pointer filename);
	}

	/** <i>native declaration : sox.h:1918</i> */
	interface sox_open_write_overwrite_permitted_callback extends Callback {
		int apply(Pointer filename);
	}

	/**
	 * Client API:<br>
	 * Returns version number string of libSoX, for example, "14.4.0".<br>
	 * @returns The version number string of libSoX, for example, "14.4.0".
	 * Original signature : <code>const char* sox_version()</code><br>
	 * <i>native declaration : sox.h:1650</i>
	 */
	String sox_version();
	/**
	 * Client API:<br>
	 * Returns information about this build of libsox.<br>
	 * @returns Pointer to a version information structure.<br>
	 * Original signature : <code>const sox_version_info_t* sox_version_info()</code><br>
	 * <i>native declaration : sox.h:1660</i>
	 */
	sox_version_info_t sox_version_info();
	/**
	 * Client API:<br>
	 * Returns a pointer to the structure with libSoX's global settings.<br>
	 * @returns a pointer to the structure with libSoX's global settings.<br>
	 * Original signature : <code>sox_globals_t* sox_get_globals()</code><br>
	 * <i>native declaration : sox.h:1670</i>
	 */
	sox_globals_t sox_get_globals();
	/**
	 * Client API:<br>
	 * Returns a pointer to the list of available encodings.<br>
	 * End of list indicated by name == NULL.<br>
	 * @returns pointer to the list of available encodings.<br>
	 * Original signature : <code>const sox_encodings_info_t* sox_get_encodings_info()</code><br>
	 * <i>native declaration : sox.h:1688</i>
	 */
	sox_encodings_info_t sox_get_encodings_info();
	/**
	 * Client API:<br>
	 * Fills in an encodinginfo with default values.<br>
	 * Original signature : <code>void sox_init_encodinginfo(sox_encodinginfo_t*)</code><br>
	 * @param e < Pointer to uninitialized encoding info structure to be initialized.<br>
	 * <i>native declaration : sox.h:1703</i>
	 */
	void sox_init_encodinginfo(sox_encodinginfo_t e);
	/**
	 * Client API:<br>
	 * Given an encoding (for example, SIGN2) and the encoded bits_per_sample (for<br>
	 * example, 16), returns the number of useful bits per sample in the decoded data<br>
	 * (for example, 16), or returns 0 to indicate that the value returned by the<br>
	 * format handler should be used instead of a pre-determined precision.<br>
	 * @returns the number of useful bits per sample in the decoded data (for example<br>
	 * 16), or returns 0 to indicate that the value returned by the format handler<br>
	 * should be used instead of a pre-determined precision.<br>
	 * Original signature : <code>int sox_precision(sox_encoding_t, unsigned)</code><br>
	 * @param encoding < Encoding for which to lookup precision information.<br>
	 * @param bits_per_sample < The number of encoded bits per sample.<br>
	 * <i>native declaration : sox.h:1720</i>
	 */
	int sox_precision(int encoding, int bits_per_sample);
	/**
	 * Client API:<br>
	 * Returns the number of items in the metadata block.<br>
	 * @returns the number of items in the metadata block.<br>
	 * Original signature : <code>size_t sox_num_comments(sox_comments_t)</code><br>
	 * @param comments < Metadata block.<br>
	 * <i>native declaration : sox.h:1732</i>
	 */
	size_t sox_num_comments(PointerByReference comments);
	/**
	 * Client API:<br>
	 * Adds an "id=value" item to the metadata block.<br>
	 * Original signature : <code>void sox_append_comment(sox_comments_t*, const char*)</code><br>
	 * @param comments < Metadata block.<br>
	 * @param item < Item to be added in "id=value" format.<br>
	 * <i>native declaration : sox.h:1742</i><br>
	 * @deprecated use the safer methods {@link #sox_append_comment(com.sun.jna.ptr.PointerByReference, java.lang.String)} and {@link #sox_append_comment(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void sox_append_comment(PointerByReference comments, Pointer item);
	/**
	 * Client API:<br>
	 * Adds an "id=value" item to the metadata block.<br>
	 * Original signature : <code>void sox_append_comment(sox_comments_t*, const char*)</code><br>
	 * @param comments < Metadata block.<br>
	 * @param item < Item to be added in "id=value" format.<br>
	 * <i>native declaration : sox.h:1742</i>
	 */
	void sox_append_comment(PointerByReference comments, String item);
	/**
	 * Client API:<br>
	 * Adds a newline-delimited list of "id=value" items to the metadata block.<br>
	 * Original signature : <code>void sox_append_comments(sox_comments_t*, const char*)</code><br>
	 * @param comments < Metadata block.<br>
	 * @param items < Newline-separated list of items to be added, for example "id1=value1\\nid2=value2".<br>
	 * <i>native declaration : sox.h:1753</i><br>
	 * @deprecated use the safer methods {@link #sox_append_comments(com.sun.jna.ptr.PointerByReference, java.lang.String)} and {@link #sox_append_comments(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	void sox_append_comments(PointerByReference comments, Pointer items);
	/**
	 * Client API:<br>
	 * Adds a newline-delimited list of "id=value" items to the metadata block.<br>
	 * Original signature : <code>void sox_append_comments(sox_comments_t*, const char*)</code><br>
	 * @param comments < Metadata block.<br>
	 * @param items < Newline-separated list of items to be added, for example "id1=value1\\nid2=value2".<br>
	 * <i>native declaration : sox.h:1753</i>
	 */
	void sox_append_comments(PointerByReference comments, String items);
	/**
	 * Client API:<br>
	 * Duplicates the metadata block.<br>
	 * @returns the copied metadata block.<br>
	 * Original signature : <code>sox_comments_t sox_copy_comments(sox_comments_t)</code><br>
	 * @param comments < Metadata block to copy.<br>
	 * <i>native declaration : sox.h:1766</i>
	 */
	PointerByReference sox_copy_comments(PointerByReference comments);
	/**
	 * Client API:<br>
	 * Frees the metadata block.<br>
	 * Original signature : <code>void sox_delete_comments(sox_comments_t*)</code><br>
	 * @param comments < Metadata block.<br>
	 * <i>native declaration : sox.h:1776</i>
	 */
	void sox_delete_comments(PointerByReference comments);
	/**
	 * Client API:<br>
	 * If "id=value" is found, return value, else return null.<br>
	 * @returns value, or null if value not found.<br>
	 * Original signature : <code>const char* sox_find_comment(sox_comments_t, const char*)</code><br>
	 * @param comments < Metadata block in which to search.<br>
	 * @param id < Id for which to search<br>
	 * <i>native declaration : sox.h:1788</i><br>
	 * @deprecated use the safer methods {@link #sox_find_comment(com.sun.jna.ptr.PointerByReference, java.lang.String)} and {@link #sox_find_comment(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	String sox_find_comment(PointerByReference comments, Pointer id);
	/**
	 * Client API:<br>
	 * If "id=value" is found, return value, else return null.<br>
	 * @returns value, or null if value not found.<br>
	 * Original signature : <code>const char* sox_find_comment(sox_comments_t, const char*)</code><br>
	 * @param comments < Metadata block in which to search.<br>
	 * @param id < Id for which to search<br>
	 * <i>native declaration : sox.h:1788</i>
	 */
	String sox_find_comment(PointerByReference comments, String id);
	/**
	 * Client API:<br>
	 * Find and load format handler plugins.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_format_init()</code><br>
	 * <i>native declaration : sox.h:1800</i>
	 */
	int sox_format_init();
	/**
	 * Client API:<br>
	 * Unload format handler plugins.<br>
	 * Original signature : <code>void sox_format_quit()</code><br>
	 * <i>native declaration : sox.h:1808</i>
	 */
	void sox_format_quit();
	/**
	 * Client API:<br>
	 * Initialize effects library.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_init()</code><br>
	 * <i>native declaration : sox.h:1817</i>
	 */
	int sox_init();
	/**
	 * Client API:<br>
	 * Close effects library and unload format handler plugins.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_quit()</code><br>
	 * <i>native declaration : sox.h:1826</i>
	 */
	int sox_quit();
	/**
	 * Client API:<br>
	 * Returns the table of format handler names and functions.<br>
	 * @returns the table of format handler names and functions.<br>
	 * Original signature : <code>const sox_format_tab_t* sox_get_format_fns()</code><br>
	 * <i>native declaration : sox.h:1836</i>
	 */
	sox_format_tab_t sox_get_format_fns();
	/**
	 * Client API:<br>
	 * Opens a decoding session for a file. Returned handle must be closed with sox_close().<br>
	 * @returns The handle for the new session, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_read(const char*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*)</code><br>
	 * @param path < Path to file to be opened (required).<br>
	 * @param signal < Information already known about audio stream, or NULL if none.<br>
	 * @param encoding < Information already known about sample encoding, or NULL if none.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * <i>native declaration : sox.h:1852</i><br>
	 * @deprecated use the safer methods {@link #sox_open_read(java.lang.String, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, java.lang.String)} and {@link #sox_open_read(com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	sox_format_t sox_open_read(Pointer path, sox_signalinfo_t signal, sox_encodinginfo_t encoding, Pointer filetype);
	/**
	 * Client API:<br>
	 * Opens a decoding session for a file. Returned handle must be closed with sox_close().<br>
	 * @returns The handle for the new session, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_read(const char*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*)</code><br>
	 * @param path < Path to file to be opened (required).<br>
	 * @param signal < Information already known about audio stream, or NULL if none.<br>
	 * @param encoding < Information already known about sample encoding, or NULL if none.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * <i>native declaration : sox.h:1852</i>
	 */
	sox_format_t sox_open_read(String path, sox_signalinfo_t signal, sox_encodinginfo_t encoding, String filetype);
	/**
	 * Client API:<br>
	 * Opens a decoding session for a memory buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The handle for the new session, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_mem_read(void*, size_t, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*)</code><br>
	 * @param buffer < Pointer to audio data buffer (required).<br>
	 * @param buffer_size < Number of bytes to read from audio data buffer.<br>
	 * @param signal < Information already known about audio stream, or NULL if none.<br>
	 * @param encoding < Information already known about sample encoding, or NULL if none.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * <i>native declaration : sox.h:1867</i><br>
	 * @deprecated use the safer methods {@link #sox_open_mem_read(com.sun.jna.Pointer, size_t, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, java.lang.String)} and {@link #sox_open_mem_read(com.sun.jna.Pointer, size_t, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	sox_format_t sox_open_mem_read(Pointer buffer, size_t buffer_size, sox_signalinfo_t signal, sox_encodinginfo_t encoding, Pointer filetype);
	/**
	 * Client API:<br>
	 * Opens a decoding session for a memory buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The handle for the new session, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_mem_read(void*, size_t, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*)</code><br>
	 * @param buffer < Pointer to audio data buffer (required).<br>
	 * @param buffer_size < Number of bytes to read from audio data buffer.<br>
	 * @param signal < Information already known about audio stream, or NULL if none.<br>
	 * @param encoding < Information already known about sample encoding, or NULL if none.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * <i>native declaration : sox.h:1867</i>
	 */
	sox_format_t sox_open_mem_read(Pointer buffer, size_t buffer_size, sox_signalinfo_t signal, sox_encodinginfo_t encoding, String filetype);
	/**
	 * Client API:<br>
	 * Returns true if the format handler for the specified file type supports the specified encoding.<br>
	 * @returns true if the format handler for the specified file type supports the specified encoding.<br>
	 * Original signature : <code>sox_bool sox_format_supports_encoding(const char*, const char*, const sox_encodinginfo_t*)</code><br>
	 * @param path < Path to file to be examined (required if filetype is NULL).<br>
	 * @param filetype < Previously-determined file type, or NULL to use extension from path.<br>
	 * @param encoding < Encoding for which format handler should be queried.<br>
	 * <i>native declaration : sox.h:1882</i><br>
	 * @deprecated use the safer methods {@link #sox_format_supports_encoding(java.lang.String, java.lang.String, com.anthemengineering.sox.jna.sox_encodinginfo_t)} and {@link #sox_format_supports_encoding(com.sun.jna.Pointer, com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_encodinginfo_t)} instead
	 */
	@Deprecated 
	int sox_format_supports_encoding(Pointer path, Pointer filetype, sox_encodinginfo_t encoding);
	/**
	 * Client API:<br>
	 * Returns true if the format handler for the specified file type supports the specified encoding.<br>
	 * @returns true if the format handler for the specified file type supports the specified encoding.<br>
	 * Original signature : <code>sox_bool sox_format_supports_encoding(const char*, const char*, const sox_encodinginfo_t*)</code><br>
	 * @param path < Path to file to be examined (required if filetype is NULL).<br>
	 * @param filetype < Previously-determined file type, or NULL to use extension from path.<br>
	 * @param encoding < Encoding for which format handler should be queried.<br>
	 * <i>native declaration : sox.h:1882</i>
	 */
	int sox_format_supports_encoding(String path, String filetype, sox_encodinginfo_t encoding);
	/**
	 * Client API:<br>
	 * Gets the format handler for a specified file type.<br>
	 * @returns The found format handler, or null if not found.<br>
	 * Original signature : <code>const sox_format_handler_t* sox_write_handler(const char*, const char*, const char**)</code><br>
	 * @param path < Path to file (required if filetype is NULL).<br>
	 * @param filetype < Filetype for which handler is needed, or NULL to use extension from path.<br>
	 * @param filetype1 < Receives the filetype that was detected. Pass NULL if not needed.<br>
	 * <i>native declaration : sox.h:1896</i><br>
	 * @deprecated use the safer methods {@link #sox_write_handler(java.lang.String, java.lang.String, java.lang.String[])} and {@link #sox_write_handler(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	sox_format_handler_t sox_write_handler(Pointer path, Pointer filetype, PointerByReference filetype1);
	/**
	 * Client API:<br>
	 * Gets the format handler for a specified file type.<br>
	 * @returns The found format handler, or null if not found.<br>
	 * Original signature : <code>const sox_format_handler_t* sox_write_handler(const char*, const char*, const char**)</code><br>
	 * @param path < Path to file (required if filetype is NULL).<br>
	 * @param filetype < Filetype for which handler is needed, or NULL to use extension from path.<br>
	 * @param filetype1 < Receives the filetype that was detected. Pass NULL if not needed.<br>
	 * <i>native declaration : sox.h:1896</i>
	 */
	sox_format_handler_t sox_write_handler(String path, String filetype, String[] filetype1);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a file. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_write(const char*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*, sox_open_write_overwrite_permitted_callback*)</code><br>
	 * @param path < Path to file to be written (required).<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1910</i><br>
	 * @deprecated use the safer methods {@link #sox_open_write(java.lang.String, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, java.lang.String, com.anthemengineering.sox.jna.sox_oob_t, com.anthemengineering.sox.jna.SoxLibrary.sox_open_write_overwrite_permitted_callback)} and {@link #sox_open_write(com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_oob_t, com.anthemengineering.sox.jna.SoxLibrary.sox_open_write_overwrite_permitted_callback)} instead
	 */
	@Deprecated 
	sox_format_t sox_open_write(Pointer path, sox_signalinfo_t signal, sox_encodinginfo_t encoding, Pointer filetype, sox_oob_t oob, SoxLibrary.sox_open_write_overwrite_permitted_callback overwrite_permitted);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a file. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_write(const char*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*, sox_open_write_overwrite_permitted_callback*)</code><br>
	 * @param path < Path to file to be written (required).<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1910</i>
	 */
	sox_format_t sox_open_write(String path, sox_signalinfo_t signal, sox_encodinginfo_t encoding, String filetype, sox_oob_t oob, SoxLibrary.sox_open_write_overwrite_permitted_callback overwrite_permitted);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a memory buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_mem_write(void*, size_t, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*)</code><br>
	 * @param buffer < Pointer to audio data buffer that receives data (required).<br>
	 * @param buffer_size < Maximum number of bytes to write to audio data buffer.<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1927</i><br>
	 * @deprecated use the safer methods {@link #sox_open_mem_write(com.sun.jna.Pointer, size_t, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, java.lang.String, com.anthemengineering.sox.jna.sox_oob_t)} and {@link #sox_open_mem_write(com.sun.jna.Pointer, size_t, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_oob_t)} instead
	 */
	@Deprecated 
	sox_format_t sox_open_mem_write(Pointer buffer, size_t buffer_size, sox_signalinfo_t signal, sox_encodinginfo_t encoding, Pointer filetype, sox_oob_t oob);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a memory buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_mem_write(void*, size_t, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*)</code><br>
	 * @param buffer < Pointer to audio data buffer that receives data (required).<br>
	 * @param buffer_size < Maximum number of bytes to write to audio data buffer.<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1927</i>
	 */
	sox_format_t sox_open_mem_write(Pointer buffer, size_t buffer_size, sox_signalinfo_t signal, sox_encodinginfo_t encoding, String filetype, sox_oob_t oob);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a memstream buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_memstream_write(char**, size_t*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*)</code><br>
	 * @param buffer_ptr < Receives pointer to audio data buffer that receives data (required).<br>
	 * @param buffer_size_ptr < Receives size of data written to audio data buffer (required).<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1944</i><br>
	 * @deprecated use the safer methods {@link #sox_open_memstream_write(com.sun.jna.ptr.PointerByReference, size_t.ByReference, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, java.lang.String, com.anthemengineering.sox.jna.sox_oob_t)} and {@link #sox_open_memstream_write(com.sun.jna.ptr.PointerByReference, size_t.ByReference, com.anthemengineering.sox.jna.sox_signalinfo_t, com.anthemengineering.sox.jna.sox_encodinginfo_t, com.sun.jna.Pointer, com.anthemengineering.sox.jna.sox_oob_t)} instead
	 */
	@Deprecated 
	sox_format_t sox_open_memstream_write(PointerByReference buffer_ptr, size_t.ByReference buffer_size_ptr, sox_signalinfo_t signal, sox_encodinginfo_t encoding, Pointer filetype, sox_oob_t oob);
	/**
	 * Client API:<br>
	 * Opens an encoding session for a memstream buffer. Returned handle must be closed with sox_close().<br>
	 * @returns The new session handle, or null on failure.<br>
	 * Original signature : <code>sox_format_t* sox_open_memstream_write(char**, size_t*, const sox_signalinfo_t*, const sox_encodinginfo_t*, const char*, const sox_oob_t*)</code><br>
	 * @param buffer_ptr < Receives pointer to audio data buffer that receives data (required).<br>
	 * @param buffer_size_ptr < Receives size of data written to audio data buffer (required).<br>
	 * @param signal < Information about desired audio stream (required).<br>
	 * @param encoding < Information about desired sample encoding, or NULL to use defaults.<br>
	 * @param filetype < Previously-determined file type, or NULL to auto-detect.<br>
	 * @param oob < Out-of-band data to add to file, or NULL if none.<br>
	 * <i>native declaration : sox.h:1944</i>
	 */
	sox_format_t sox_open_memstream_write(PointerByReference buffer_ptr, size_t.ByReference buffer_size_ptr, sox_signalinfo_t signal, sox_encodinginfo_t encoding, String filetype, sox_oob_t oob);
	/**
	 * Client API:<br>
	 * Reads samples from a decoding session into a sample buffer.<br>
	 * @returns Number of samples decoded, or 0 for EOF.<br>
	 * Original signature : <code>size_t sox_read(sox_format_t*, sox_sample_t*, size_t)</code><br>
	 * @param ft < Format pointer.<br>
	 * @param buf < Buffer from which to read samples.<br>
	 * @param len < Number of samples available in buf.<br>
	 * <i>native declaration : sox.h:1960</i><br>
	 * @deprecated use the safer methods {@link #sox_read(com.anthemengineering.sox.jna.sox_format_t, java.nio.IntBuffer, size_t)} and {@link #sox_read(com.anthemengineering.sox.jna.sox_format_t, com.sun.jna.ptr.IntByReference, size_t)} instead
	 */
	@Deprecated 
	size_t sox_read(sox_format_t ft, IntByReference buf, size_t len);
	/**
	 * Client API:<br>
	 * Reads samples from a decoding session into a sample buffer.<br>
	 * @returns Number of samples decoded, or 0 for EOF.<br>
	 * Original signature : <code>size_t sox_read(sox_format_t*, sox_sample_t*, size_t)</code><br>
	 * @param ft < Format pointer.<br>
	 * @param buf < Buffer from which to read samples.<br>
	 * @param len < Number of samples available in buf.<br>
	 * <i>native declaration : sox.h:1960</i>
	 */
	size_t sox_read(sox_format_t ft, IntBuffer buf, size_t len);
	/**
	 * Client API:<br>
	 * Writes samples to an encoding session from a sample buffer.<br>
	 * @returns Number of samples encoded.<br>
	 * Original signature : <code>size_t sox_write(sox_format_t*, const sox_sample_t*, size_t)</code><br>
	 * @param ft < Format pointer.<br>
	 * @param buf < Buffer from which to read samples.<br>
	 * @param len < Number of samples available in buf.<br>
	 * <i>native declaration : sox.h:1973</i><br>
	 * @deprecated use the safer methods {@link #sox_write(com.anthemengineering.sox.jna.sox_format_t, java.nio.IntBuffer, size_t)} and {@link #sox_write(com.anthemengineering.sox.jna.sox_format_t, com.sun.jna.ptr.IntByReference, size_t)} instead
	 */
	@Deprecated 
	size_t sox_write(sox_format_t ft, IntByReference buf, size_t len);
	/**
	 * Client API:<br>
	 * Writes samples to an encoding session from a sample buffer.<br>
	 * @returns Number of samples encoded.<br>
	 * Original signature : <code>size_t sox_write(sox_format_t*, const sox_sample_t*, size_t)</code><br>
	 * @param ft < Format pointer.<br>
	 * @param buf < Buffer from which to read samples.<br>
	 * @param len < Number of samples available in buf.<br>
	 * <i>native declaration : sox.h:1973</i>
	 */
	size_t sox_write(sox_format_t ft, IntBuffer buf, size_t len);
	/**
	 * Client API:<br>
	 * Closes an encoding or decoding session.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_close(sox_format_t*)</code><br>
	 * @param ft < Format pointer.<br>
	 * <i>native declaration : sox.h:1986</i>
	 */
	int sox_close(sox_format_t ft);
	/**
	 * Client API:<br>
	 * Sets the location at which next samples will be decoded. Returns SOX_SUCCESS if successful.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_seek(sox_format_t*, sox_uint64_t, int)</code><br>
	 * @param ft < Format pointer.<br>
	 * @param offset < Sample offset at which to position reader.<br>
	 * @param whence < Set to SOX_SEEK_SET.<br>
	 * <i>native declaration : sox.h:1997</i>
	 */
	int sox_seek(sox_format_t ft, long offset, int whence);
	/**
	 * Client API:<br>
	 * Finds a format handler by name.<br>
	 * @returns Format handler data, or null if not found.<br>
	 * Original signature : <code>const sox_format_handler_t* sox_find_format(const char*, sox_bool)</code><br>
	 * @param name < Name of format handler to find.<br>
	 * @param ignore_devices < Set to true to ignore device names.<br>
	 * <i>native declaration : sox.h:2011</i><br>
	 * @deprecated use the safer methods {@link #sox_find_format(java.lang.String, int)} and {@link #sox_find_format(com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated 
	sox_format_handler_t sox_find_format(Pointer name, int ignore_devices);
	/**
	 * Client API:<br>
	 * Finds a format handler by name.<br>
	 * @returns Format handler data, or null if not found.<br>
	 * Original signature : <code>const sox_format_handler_t* sox_find_format(const char*, sox_bool)</code><br>
	 * @param name < Name of format handler to find.<br>
	 * @param ignore_devices < Set to true to ignore device names.<br>
	 * <i>native declaration : sox.h:2011</i>
	 */
	sox_format_handler_t sox_find_format(String name, int ignore_devices);
	/**
	 * Client API:<br>
	 * Returns global parameters for effects<br>
	 * @returns global parameters for effects.<br>
	 * Original signature : <code>sox_effects_globals_t* sox_get_effects_globals()</code><br>
	 * <i>native declaration : sox.h:2024</i>
	 */
	sox_effects_globals_t sox_get_effects_globals();
	/**
	 * Client API:<br>
	 * Finds the effect handler with the given name.<br>
	 * @returns Effect pointer, or null if not found.<br>
	 * Original signature : <code>const sox_effect_handler_t* sox_find_effect(const char*)</code><br>
	 * @param name < Name of effect to find.<br>
	 * <i>native declaration : sox.h:2040</i><br>
	 * @deprecated use the safer methods {@link #sox_find_effect(java.lang.String)} and {@link #sox_find_effect(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	sox_effect_handler_t sox_find_effect(Pointer name);
	/**
	 * Client API:<br>
	 * Finds the effect handler with the given name.<br>
	 * @returns Effect pointer, or null if not found.<br>
	 * Original signature : <code>const sox_effect_handler_t* sox_find_effect(const char*)</code><br>
	 * @param name < Name of effect to find.<br>
	 * <i>native declaration : sox.h:2040</i>
	 */
	sox_effect_handler_t sox_find_effect(String name);
	/**
	 * Client API:<br>
	 * Creates an effect using the given handler.<br>
	 * @returns The new effect, or null if not found.<br>
	 * Original signature : <code>sox_effect_t* sox_create_effect(const sox_effect_handler_t*)</code><br>
	 * @param eh < Handler to use for effect.<br>
	 * <i>native declaration : sox.h:2052</i>
	 */
	sox_effect_t sox_create_effect(sox_effect_handler_t eh);
	/**
	 * Client API:<br>
	 * Applies the command-line options to the effect.<br>
	 * @returns the number of arguments consumed.<br>
	 * Original signature : <code>int sox_effect_options(sox_effect_t*, int, const char*[])</code><br>
	 * @param effp < Effect pointer on which to set options.<br>
	 * @param argc < Number of arguments in argv.<br>
	 * @param argv < Array of command-line options.<br>
	 * <i>native declaration : sox.h:2063</i><br>
	 * @deprecated use the safer methods {@link #sox_effect_options(com.anthemengineering.sox.jna.sox_effect_t, int, PointerByReference[])} and {@link #sox_effect_options(com.anthemengineering.sox.jna.sox_effect_t, int, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated 
	int sox_effect_options(sox_effect_t effp, int argc, PointerByReference argv);
	/**
	 * Client API:<br>
	 * Applies the command-line options to the effect.<br>
	 * @returns the number of arguments consumed.<br>
	 * Original signature : <code>int sox_effect_options(sox_effect_t*, int, const char*[])</code><br>
	 * @param effp < Effect pointer on which to set options.<br>
	 * @param argc < Number of arguments in argv.<br>
	 * @param argv < Array of command-line options.<br>
	 * <i>native declaration : sox.h:2063</i>
	 */
	int sox_effect_options(sox_effect_t effp, int argc, PointerByReference[] argv);
	/**
	 * Client API:<br>
	 * Returns an array containing the known effect handlers.<br>
	 * @returns An array containing the known effect handlers.<br>
	 * Original signature : <code>const sox_effect_fn_t* sox_get_effect_fns()</code><br>
	 * <i>native declaration : sox.h:2077</i>
	 */
	SoxLibrary.sox_effect_fn_t sox_get_effect_fns();
	/**
	 * Client API:<br>
	 * Initializes an effects chain. Returned handle must be closed with sox_delete_effects_chain().<br>
	 * @returns Handle, or null on failure.<br>
	 * Original signature : <code>sox_effects_chain_t* sox_create_effects_chain(const sox_encodinginfo_t*, const sox_encodinginfo_t*)</code><br>
	 * @param in_enc < Input encoding.<br>
	 * @param out_enc < Output encoding.<br>
	 * <i>native declaration : sox.h:2093</i>
	 */
	sox_effects_chain_t sox_create_effects_chain(sox_encodinginfo_t in_enc, sox_encodinginfo_t out_enc);
	/**
	 * Client API:<br>
	 * Closes an effects chain.<br>
	 * Original signature : <code>void sox_delete_effects_chain(sox_effects_chain_t*)</code><br>
	 * @param ecp < Effects chain pointer.<br>
	 * <i>native declaration : sox.h:2104</i>
	 */
	void sox_delete_effects_chain(sox_effects_chain_t ecp);
	/**
	 * Client API:<br>
	 * Adds an effect to the effects chain, returns SOX_SUCCESS if successful.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_add_effect(sox_effects_chain_t*, sox_effect_t*, sox_signalinfo_t*, const sox_signalinfo_t*)</code><br>
	 * @param chain < Effects chain to which effect should be added .<br>
	 * @param effp < Effect to be added.<br>
	 * @param in < Input format.<br>
	 * @param out < Output format.<br>
	 * <i>native declaration : sox.h:2115</i>
	 */
	int sox_add_effect(sox_effects_chain_t chain, sox_effect_t effp, sox_signalinfo_t in, sox_signalinfo_t out);
	/**
	 * Client API:<br>
	 * Runs the effects chain, returns SOX_SUCCESS if successful.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_flow_effects(sox_effects_chain_t*, sox_flow_effects_callback, void*)</code><br>
	 * @param chain < Effects chain to run.<br>
	 * @param callback < Callback for monitoring flow progress.<br>
	 * @param client_data < Data to pass into callback.<br>
	 * <i>native declaration : sox.h:2129</i>
	 */
	int sox_flow_effects(sox_effects_chain_t chain, SoxLibrary.sox_flow_effects_callback callback, Pointer client_data);
	/**
	 * Client API:<br>
	 * Gets the number of clips that occurred while running an effects chain.<br>
	 * @returns the number of clips that occurred while running an effects chain.<br>
	 * Original signature : <code>sox_uint64_t sox_effects_clips(sox_effects_chain_t*)</code><br>
	 * @param chain < Effects chain from which to read clip information.<br>
	 * <i>native declaration : sox.h:2142</i>
	 */
	long sox_effects_clips(sox_effects_chain_t chain);
	/**
	 * Client API:<br>
	 * Shuts down an effect (calls stop on each of its flows).<br>
	 * @returns the number of clips from all flows.<br>
	 * Original signature : <code>sox_uint64_t sox_stop_effect(sox_effect_t*)</code><br>
	 * @param effp < Effect to stop.<br>
	 * <i>native declaration : sox.h:2153</i>
	 */
	long sox_stop_effect(sox_effect_t effp);
	/**
	 * Client API:<br>
	 * Adds an already-initialized effect to the end of the chain.<br>
	 * Original signature : <code>void sox_push_effect_last(sox_effects_chain_t*, sox_effect_t*)</code><br>
	 * @param chain < Effects chain to which effect should be added.<br>
	 * @param effp < Effect to be added.<br>
	 * <i>native declaration : sox.h:2163</i>
	 */
	void sox_push_effect_last(sox_effects_chain_t chain, sox_effect_t effp);
	/**
	 * Client API:<br>
	 * Removes and returns an effect from the end of the chain.<br>
	 * @returns the removed effect, or null if no effects.<br>
	 * Original signature : <code>sox_effect_t* sox_pop_effect_last(sox_effects_chain_t*)</code><br>
	 * @param chain < Effects chain from which to remove an effect.<br>
	 * <i>native declaration : sox.h:2176</i>
	 */
	sox_effect_t sox_pop_effect_last(sox_effects_chain_t chain);
	/**
	 * Client API:<br>
	 * Shut down and delete an effect.<br>
	 * Original signature : <code>void sox_delete_effect(sox_effect_t*)</code><br>
	 * @param effp < Effect to be deleted.<br>
	 * <i>native declaration : sox.h:2186</i>
	 */
	void sox_delete_effect(sox_effect_t effp);
	/**
	 * Client API:<br>
	 * Shut down and delete the last effect in the chain.<br>
	 * Original signature : <code>void sox_delete_effect_last(sox_effects_chain_t*)</code><br>
	 * @param chain < Effects chain from which to remove the last effect.<br>
	 * <i>native declaration : sox.h:2196</i>
	 */
	void sox_delete_effect_last(sox_effects_chain_t chain);
	/**
	 * Client API:<br>
	 * Shut down and delete all effects in the chain.<br>
	 * Original signature : <code>void sox_delete_effects(sox_effects_chain_t*)</code><br>
	 * @param chain < Effects chain from which to delete effects.<br>
	 * <i>native declaration : sox.h:2206</i>
	 */
	void sox_delete_effects(sox_effects_chain_t chain);
	/**
	 * Client API:<br>
	 * Gets the sample offset of the start of the trim, useful for efficiently<br>
	 * skipping the part that will be trimmed anyway (get trim start, seek, then<br>
	 * clear trim start).<br>
	 * @returns the sample offset of the start of the trim.<br>
	 * Original signature : <code>sox_uint64_t sox_trim_get_start(sox_effect_t*)</code><br>
	 * @param effp < Trim effect.<br>
	 * <i>native declaration : sox.h:2219</i>
	 */
	long sox_trim_get_start(sox_effect_t effp);
	/**
	 * Client API:<br>
	 * Clears the start of the trim to 0.<br>
	 * Original signature : <code>void sox_trim_clear_start(sox_effect_t*)</code><br>
	 * @param effp < Trim effect.<br>
	 * <i>native declaration : sox.h:2229</i>
	 */
	void sox_trim_clear_start(sox_effect_t effp);
	/**
	 * Client API:<br>
	 * Returns true if the specified file is a known playlist file type.<br>
	 * @returns true if the specified file is a known playlist file type.<br>
	 * Original signature : <code>sox_bool sox_is_playlist(const char*)</code><br>
	 * @param filename < Name of file to examine.<br>
	 * <i>native declaration : sox.h:2240</i><br>
	 * @deprecated use the safer methods {@link #sox_is_playlist(java.lang.String)} and {@link #sox_is_playlist(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int sox_is_playlist(Pointer filename);
	/**
	 * Client API:<br>
	 * Returns true if the specified file is a known playlist file type.<br>
	 * @returns true if the specified file is a known playlist file type.<br>
	 * Original signature : <code>sox_bool sox_is_playlist(const char*)</code><br>
	 * @param filename < Name of file to examine.<br>
	 * <i>native declaration : sox.h:2240</i>
	 */
	int sox_is_playlist(String filename);
	/**
	 * Client API:<br>
	 * Parses the specified playlist file.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_parse_playlist(sox_playlist_callback_t, void*, const const char*)</code><br>
	 * @param callback < Callback to call for each item in the playlist.<br>
	 * @param p < Data to pass to callback.<br>
	 * @param listname < Filename of playlist file.<br>
	 * <i>native declaration : sox.h:2251</i><br>
	 * @deprecated use the safer methods {@link #sox_parse_playlist(com.anthemengineering.sox.jna.SoxLibrary.sox_playlist_callback_t, com.sun.jna.Pointer, java.lang.String)} and {@link #sox_parse_playlist(com.anthemengineering.sox.jna.SoxLibrary.sox_playlist_callback_t, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int sox_parse_playlist(SoxLibrary.sox_playlist_callback_t callback, Pointer p, Pointer listname);
	/**
	 * Client API:<br>
	 * Parses the specified playlist file.<br>
	 * @returns SOX_SUCCESS if successful.<br>
	 * Original signature : <code>int sox_parse_playlist(sox_playlist_callback_t, void*, const const char*)</code><br>
	 * @param callback < Callback to call for each item in the playlist.<br>
	 * @param p < Data to pass to callback.<br>
	 * @param listname < Filename of playlist file.<br>
	 * <i>native declaration : sox.h:2251</i>
	 */
	int sox_parse_playlist(SoxLibrary.sox_playlist_callback_t callback, Pointer p, String listname);
	/**
	 * Client API:<br>
	 * Converts a SoX error code into an error string.<br>
	 * @returns error string corresponding to the specified error code,<br>
	 * or a generic message if the error code is not recognized.<br>
	 * Original signature : <code>const char* sox_strerror(int)</code><br>
	 * @param sox_errno < Error code to look up.<br>
	 * <i>native declaration : sox.h:2266</i>
	 */
	String sox_strerror(int sox_errno);
	/**
	 * Client API:<br>
	 * Gets the basename of the specified file; for example, the basename of<br>
	 * "/a/b/c.d" would be "c".<br>
	 * @returns the number of characters written to base_buffer, excluding the null,<br>
	 * or 0 on failure.<br>
	 * Original signature : <code>size_t sox_basename(char*, size_t, const char*)</code><br>
	 * @param base_buffer < Buffer into which basename should be written.<br>
	 * @param base_buffer_len < Size of base_buffer, in bytes.<br>
	 * @param filename < Filename from which to extract basename.<br>
	 * <i>native declaration : sox.h:2279</i><br>
	 * @deprecated use the safer methods {@link #sox_basename(java.nio.ByteBuffer, size_t, java.lang.String)} and {@link #sox_basename(com.sun.jna.Pointer, size_t, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	size_t sox_basename(Pointer base_buffer, size_t base_buffer_len, Pointer filename);
	/**
	 * Client API:<br>
	 * Gets the basename of the specified file; for example, the basename of<br>
	 * "/a/b/c.d" would be "c".<br>
	 * @returns the number of characters written to base_buffer, excluding the null,<br>
	 * or 0 on failure.<br>
	 * Original signature : <code>size_t sox_basename(char*, size_t, const char*)</code><br>
	 * @param base_buffer < Buffer into which basename should be written.<br>
	 * @param base_buffer_len < Size of base_buffer, in bytes.<br>
	 * @param filename < Filename from which to extract basename.<br>
	 * <i>native declaration : sox.h:2279</i>
	 */
	size_t sox_basename(ByteBuffer base_buffer, size_t base_buffer_len, String filename);
	/**
	 * Plugins API:<br>
	 * Print a fatal error in libSoX.<br>
	 * Original signature : <code>void lsx_fail_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2298</i><br>
	 */
	@Deprecated 
	void lsx_fail_impl(Pointer fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print a fatal error in libSoX.<br>
	 * Original signature : <code>void lsx_fail_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2298</i>
	 */
	void lsx_fail_impl(String fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print a warning in libSoX.<br>
	 * Original signature : <code>void lsx_warn_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2309</i><br>
	 */
	@Deprecated 
	void lsx_warn_impl(Pointer fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print a warning in libSoX.<br>
	 * Original signature : <code>void lsx_warn_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2309</i>
	 */
	void lsx_warn_impl(String fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print an informational message in libSoX.<br>
	 * Original signature : <code>void lsx_report_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2320</i><br>
	 */
	@Deprecated 
	void lsx_report_impl(Pointer fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print an informational message in libSoX.<br>
	 * Original signature : <code>void lsx_report_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2320</i>
	 */
	void lsx_report_impl(String fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print a debug message in libSoX.<br>
	 * Original signature : <code>void lsx_debug_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2331</i><br>
	 */
	@Deprecated 
	void lsx_debug_impl(Pointer fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Print a debug message in libSoX.<br>
	 * Original signature : <code>void lsx_debug_impl(const char*, null)</code><br>
	 * @param fmt < printf-style format string.<br>
	 * <i>native declaration : sox.h:2331</i>
	 */
	void lsx_debug_impl(String fmt, Object... varArgs1);
	/**
	 * Plugins API:<br>
	 * Looks up an enumeration by name in an array of lsx_enum_items.<br>
	 * @returns the corresponding item, or null if not found.<br>
	 * Original signature : <code>const lsx_enum_item* lsx_find_enum_text(const char*, const lsx_enum_item*, int)</code><br>
	 * @param text < Name of enumeration to find.<br>
	 * @param lsx_enum_items < Array of items to search, with text == NULL for last item.<br>
	 * @param flags < Search flags: 0 (case-insensitive) or lsx_find_enum_item_case_sensitive (case-sensitive).<br>
	 * <i>native declaration : sox.h:2397</i><br>
	 * @deprecated use the safer methods {@link #lsx_find_enum_text(java.lang.String, com.anthemengineering.sox.jna.lsx_enum_item, int)} and {@link #lsx_find_enum_text(com.sun.jna.Pointer, com.anthemengineering.sox.jna.lsx_enum_item, int)} instead
	 */
	@Deprecated 
	lsx_enum_item lsx_find_enum_text(Pointer text, lsx_enum_item lsx_enum_items, int flags);
	/**
	 * Plugins API:<br>
	 * Looks up an enumeration by name in an array of lsx_enum_items.<br>
	 * @returns the corresponding item, or null if not found.<br>
	 * Original signature : <code>const lsx_enum_item* lsx_find_enum_text(const char*, const lsx_enum_item*, int)</code><br>
	 * @param text < Name of enumeration to find.<br>
	 * @param lsx_enum_items < Array of items to search, with text == NULL for last item.<br>
	 * @param flags < Search flags: 0 (case-insensitive) or lsx_find_enum_item_case_sensitive (case-sensitive).<br>
	 * <i>native declaration : sox.h:2397</i>
	 */
	lsx_enum_item lsx_find_enum_text(String text, lsx_enum_item lsx_enum_items, int flags);
	/**
	 * Plugins API:<br>
	 * Looks up an enumeration by value in an array of lsx_enum_items.<br>
	 * @returns the corresponding item, or null if not found.<br>
	 * Original signature : <code>const lsx_enum_item* lsx_find_enum_value(unsigned, const lsx_enum_item*)</code><br>
	 * @param value < Enumeration value to find.<br>
	 * @param lsx_enum_items < Array of items to search, with text == NULL for last item.<br>
	 * <i>native declaration : sox.h:2411</i>
	 */
	lsx_enum_item lsx_find_enum_value(int value, lsx_enum_item lsx_enum_items);
	/**
	 * Plugins API:<br>
	 * Looks up a command-line argument in a set of enumeration names, showing an<br>
	 * error message if the argument is not found in the set of names.<br>
	 * @returns The enumeration value corresponding to the matching enumeration, or<br>
	 * INT_MAX if the argument does not match any enumeration name.<br>
	 * Original signature : <code>int lsx_enum_option(int, const char*, const lsx_enum_item*)</code><br>
	 * @param c < Option character to which arg is associated, for example with -a, c would be 'a'.<br>
	 * @param arg < Argument to find in enumeration list.<br>
	 * @param items < Array of items to search, with text == NULL for last item.<br>
	 * <i>native declaration : sox.h:2426</i><br>
	 * @deprecated use the safer methods {@link #lsx_enum_option(int, java.lang.String, com.anthemengineering.sox.jna.lsx_enum_item)} and {@link #lsx_enum_option(int, com.sun.jna.Pointer, com.anthemengineering.sox.jna.lsx_enum_item)} instead
	 */
	@Deprecated 
	int lsx_enum_option(int c, Pointer arg, lsx_enum_item items);
	/**
	 * Plugins API:<br>
	 * Looks up a command-line argument in a set of enumeration names, showing an<br>
	 * error message if the argument is not found in the set of names.<br>
	 * @returns The enumeration value corresponding to the matching enumeration, or<br>
	 * INT_MAX if the argument does not match any enumeration name.<br>
	 * Original signature : <code>int lsx_enum_option(int, const char*, const lsx_enum_item*)</code><br>
	 * @param c < Option character to which arg is associated, for example with -a, c would be 'a'.<br>
	 * @param arg < Argument to find in enumeration list.<br>
	 * @param items < Array of items to search, with text == NULL for last item.<br>
	 * <i>native declaration : sox.h:2426</i>
	 */
	int lsx_enum_option(int c, String arg, lsx_enum_item items);
	/**
	 * Plugins API:<br>
	 * Determines whether the specified string ends with the specified suffix (case-sensitive).<br>
	 * @returns true if the specified string ends with the specified suffix.<br>
	 * Original signature : <code>sox_bool lsx_strends(const char*, const char*)</code><br>
	 * @param str < String to search.<br>
	 * @param end < Suffix to search for.<br>
	 * <i>native declaration : sox.h:2440</i><br>
	 * @deprecated use the safer methods {@link #lsx_strends(java.lang.String, java.lang.String)} and {@link #lsx_strends(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int lsx_strends(Pointer str, Pointer end);
	/**
	 * Plugins API:<br>
	 * Determines whether the specified string ends with the specified suffix (case-sensitive).<br>
	 * @returns true if the specified string ends with the specified suffix.<br>
	 * Original signature : <code>sox_bool lsx_strends(const char*, const char*)</code><br>
	 * @param str < String to search.<br>
	 * @param end < Suffix to search for.<br>
	 * <i>native declaration : sox.h:2440</i>
	 */
	int lsx_strends(String str, String end);
	/**
	 * Plugins API:<br>
	 * Finds the file extension for a filename.<br>
	 * @returns the file extension, not including the '.', or null if filename does<br>
	 * not have an extension.<br>
	 * Original signature : <code>const char* lsx_find_file_extension(const char*)</code><br>
	 * @param pathname < Filename to search for extension.<br>
	 * <i>native declaration : sox.h:2454</i><br>
	 * @deprecated use the safer methods {@link #lsx_find_file_extension(java.lang.String)} and {@link #lsx_find_file_extension(com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	String lsx_find_file_extension(Pointer pathname);
	/**
	 * Plugins API:<br>
	 * Finds the file extension for a filename.<br>
	 * @returns the file extension, not including the '.', or null if filename does<br>
	 * not have an extension.<br>
	 * Original signature : <code>const char* lsx_find_file_extension(const char*)</code><br>
	 * @param pathname < Filename to search for extension.<br>
	 * <i>native declaration : sox.h:2454</i>
	 */
	String lsx_find_file_extension(String pathname);
	/**
	 * Plugins API:<br>
	 * Formats the specified number with up to three significant figures and adds a<br>
	 * metric suffix in place of the exponent, such as 1.23G.<br>
	 * @returns A static buffer with the formatted number, valid until the next time<br>
	 * this function is called (note: not thread safe).<br>
	 * Original signature : <code>const char* lsx_sigfigs3(double)</code><br>
	 * @param number < Number to be formatted.<br>
	 * <i>native declaration : sox.h:2468</i>
	 */
	String lsx_sigfigs3(double number);
	/**
	 * Plugins API:<br>
	 * Formats the specified number as a percentage, showing up to three significant<br>
	 * figures.<br>
	 * @returns A static buffer with the formatted number, valid until the next time<br>
	 * this function is called (note: not thread safe).<br>
	 * Original signature : <code>const char* lsx_sigfigs3p(double)</code><br>
	 * @param percentage < Number to be formatted.<br>
	 * <i>native declaration : sox.h:2482</i>
	 */
	String lsx_sigfigs3p(double percentage);
	/**
	 * Plugins API:<br>
	 * Allocates, deallocates, or resizes; like C's realloc, except that this version<br>
	 * terminates the running application if unable to allocate the requested memory.<br>
	 * @returns New buffer, or null if buffer was freed.<br>
	 * Original signature : <code>void* lsx_realloc(void*, size_t)</code><br>
	 * @param ptr < Pointer to be freed or resized, or null if allocating a new buffer.<br>
	 * @param newsize < New size for buffer, or 0 to free the buffer.<br>
	 * <i>native declaration : sox.h:2495</i>
	 */
	Pointer lsx_realloc(Pointer ptr, size_t newsize);
	/**
	 * Plugins API:<br>
	 * Like strcmp, except that the characters are compared without regard to case.<br>
	 * @returns 0 (s1 == s2), negative (s1 < s2), or positive (s1 > s2).<br>
	 * Original signature : <code>int lsx_strcasecmp(const char*, const char*)</code><br>
	 * @param s1 < First string.<br>
	 * @param s2 < Second string.<br>
	 * <i>native declaration : sox.h:2508</i><br>
	 * @deprecated use the safer methods {@link #lsx_strcasecmp(java.lang.String, java.lang.String)} and {@link #lsx_strcasecmp(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int lsx_strcasecmp(Pointer s1, Pointer s2);
	/**
	 * Plugins API:<br>
	 * Like strcmp, except that the characters are compared without regard to case.<br>
	 * @returns 0 (s1 == s2), negative (s1 < s2), or positive (s1 > s2).<br>
	 * Original signature : <code>int lsx_strcasecmp(const char*, const char*)</code><br>
	 * @param s1 < First string.<br>
	 * @param s2 < Second string.<br>
	 * <i>native declaration : sox.h:2508</i>
	 */
	int lsx_strcasecmp(String s1, String s2);
	/**
	 * Plugins API:<br>
	 * Like strncmp, except that the characters are compared without regard to case.<br>
	 * @returns 0 (s1 == s2), negative (s1 < s2), or positive (s1 > s2).<br>
	 * Original signature : <code>int lsx_strncasecmp(const char*, const char*, size_t)</code><br>
	 * @param s1 < First string.<br>
	 * @param s2 < Second string.<br>
	 * @param n < Maximum number of characters to examine.<br>
	 * <i>native declaration : sox.h:2522</i><br>
	 * @deprecated use the safer methods {@link #lsx_strncasecmp(java.lang.String, java.lang.String, size_t)} and {@link #lsx_strncasecmp(com.sun.jna.Pointer, com.sun.jna.Pointer, size_t)} instead
	 */
	@Deprecated 
	int lsx_strncasecmp(Pointer s1, Pointer s2, size_t n);
	/**
	 * Plugins API:<br>
	 * Like strncmp, except that the characters are compared without regard to case.<br>
	 * @returns 0 (s1 == s2), negative (s1 < s2), or positive (s1 > s2).<br>
	 * Original signature : <code>int lsx_strncasecmp(const char*, const char*, size_t)</code><br>
	 * @param s1 < First string.<br>
	 * @param s2 < Second string.<br>
	 * @param n < Maximum number of characters to examine.<br>
	 * <i>native declaration : sox.h:2522</i>
	 */
	int lsx_strncasecmp(String s1, String s2, size_t n);
	/**
	 * Plugins API:<br>
	 * Initializes an lsx_getopt_t structure for use with lsx_getopt.<br>
	 * Original signature : <code>void lsx_getopt_init(int, const char**, const char*, const lsx_option_t*, lsx_getopt_flags_t, int, lsx_getopt_t*)</code><br>
	 * @param argc < Number of arguments in argv<br>
	 * @param argv < Array of arguments<br>
	 * @param shortopts < Short options, for example ":abc:def::ghi" (+/- not supported)<br>
	 * @param longopts < Array of long option descriptors<br>
	 * @param flags < Flags for longonly and opterr<br>
	 * @param first < First argv to check (usually 1)<br>
	 * @param state < State object to be initialized<br>
	 * <i>native declaration : sox.h:2582</i><br>
	 * @deprecated use the safer methods {@link #lsx_getopt_init(int, java.lang.String[], java.lang.String, com.anthemengineering.sox.jna.lsx_option_t, int, int, com.anthemengineering.sox.jna.lsx_getopt_t)} and {@link #lsx_getopt_init(int, com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.anthemengineering.sox.jna.lsx_option_t, int, int, com.anthemengineering.sox.jna.lsx_getopt_t)} instead
	 */
	@Deprecated 
	void lsx_getopt_init(int argc, PointerByReference argv, Pointer shortopts, lsx_option_t longopts, int flags, int first, lsx_getopt_t state);
	/**
	 * Plugins API:<br>
	 * Initializes an lsx_getopt_t structure for use with lsx_getopt.<br>
	 * Original signature : <code>void lsx_getopt_init(int, const char**, const char*, const lsx_option_t*, lsx_getopt_flags_t, int, lsx_getopt_t*)</code><br>
	 * @param argc < Number of arguments in argv<br>
	 * @param argv < Array of arguments<br>
	 * @param shortopts < Short options, for example ":abc:def::ghi" (+/- not supported)<br>
	 * @param longopts < Array of long option descriptors<br>
	 * @param flags < Flags for longonly and opterr<br>
	 * @param first < First argv to check (usually 1)<br>
	 * @param state < State object to be initialized<br>
	 * <i>native declaration : sox.h:2582</i>
	 */
	void lsx_getopt_init(int argc, String[] argv, String shortopts, lsx_option_t longopts, int flags, int first, lsx_getopt_t state);
	/**
	 * Plugins API:<br>
	 * Gets the next option. Options are parameters that start with "-" or "--".<br>
	 * If no more options, returns -1. If unrecognized short option, returns '?'.<br>
	 * If a recognized short option is missing a required argument,<br>
	 * return (shortopts[0]==':' ? ':' : '?'). If successfully recognized short<br>
	 * option, return the recognized character. If successfully recognized long<br>
	 * option, returns (option.flag ? 0 : option.val).<br>
	 * Note: lsx_getopt does not permute the non-option arguments.<br>
	 * @returns option character (short), val or 0 (long), or -1 (no more).<br>
	 * Original signature : <code>int lsx_getopt(lsx_getopt_t*)</code><br>
	 * @param state < The getopt state pointer.<br>
	 * <i>native declaration : sox.h:2605</i>
	 */
	int lsx_getopt(lsx_getopt_t state);
	/**
	 * Plugins API:<br>
	 * Gets the file length, or 0 if the file is not seekable/normal.<br>
	 * @returns The file length, or 0 if the file is not seekable/normal.<br>
	 * Original signature : <code>sox_uint64_t lsx_filelength(sox_format_t*)</code><br>
	 * <i>native declaration : sox.h:2616</i>
	 */
	long lsx_filelength(sox_format_t ft);
}
